"""
Provide classes to perform the groupby aggregate operations.

These are not exposed to the user and provide implementations of the grouping
operations, primarily in cython. These classes (BaseGrouper and BinGrouper)
are contained *in* the SeriesGroupBy and DataFrameGroupBy objects.
"""

import collections
<<<<<<< HEAD
=======
from typing import List, Optional, Sequence, Tuple, Type
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

import numpy as np

from pandas._libs import NaT, iNaT, lib
import pandas._libs.groupby as libgroupby
<<<<<<< HEAD
import pandas._libs.reduction as reduction
=======
import pandas._libs.reduction as libreduction
from pandas._typing import FrameOrSeries
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
from pandas.errors import AbstractMethodError
from pandas.util._decorators import cache_readonly

from pandas.core.dtypes.common import (
    ensure_float64,
    ensure_int64,
    ensure_int_or_float,
<<<<<<< HEAD
    ensure_object,
=======
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    ensure_platform_int,
    is_bool_dtype,
    is_categorical_dtype,
    is_complex_dtype,
    is_datetime64_any_dtype,
<<<<<<< HEAD
    is_integer_dtype,
    is_numeric_dtype,
=======
    is_datetime64tz_dtype,
    is_extension_array_dtype,
    is_integer_dtype,
    is_numeric_dtype,
    is_period_dtype,
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    is_sparse,
    is_timedelta64_dtype,
    needs_i8_conversion,
)
from pandas.core.dtypes.missing import _maybe_fill, isna

import pandas.core.algorithms as algorithms
from pandas.core.base import SelectionMixin
import pandas.core.common as com
from pandas.core.frame import DataFrame
from pandas.core.generic import NDFrame
<<<<<<< HEAD
from pandas.core.groupby import base
from pandas.core.index import Index, MultiIndex, ensure_index
=======
from pandas.core.groupby import base, grouper
from pandas.core.indexes.api import Index, MultiIndex, ensure_index
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
from pandas.core.series import Series
from pandas.core.sorting import (
    compress_group_index,
    decons_obs_group_ids,
    get_flattened_iterator,
    get_group_index,
    get_group_index_sorter,
    get_indexer_dict,
)


<<<<<<< HEAD
def generate_bins_generic(values, binner, closed):
    """
    Generate bin edge offsets and bin labels for one array using another array
    which has bin edge values. Both arrays must be sorted.

    Parameters
    ----------
    values : array of values
    binner : a comparable array of values representing bins into which to bin
        the first array. Note, 'values' end-points must fall within 'binner'
        end-points.
    closed : which end of bin is closed; left (default), right

    Returns
    -------
    bins : array of offsets (into 'values' argument) of bins.
        Zero and last edge are excluded in result, so for instance the first
        bin is values[0:bin[0]] and the last is values[bin[-1]:]
    """
    lenidx = len(values)
    lenbin = len(binner)

    if lenidx <= 0 or lenbin <= 0:
        raise ValueError("Invalid length for values or for binner")

    # check binner fits data
    if values[0] < binner[0]:
        raise ValueError("Values falls before first bin")

    if values[lenidx - 1] > binner[lenbin - 1]:
        raise ValueError("Values falls after last bin")

    bins = np.empty(lenbin - 1, dtype=np.int64)

    j = 0  # index into values
    bc = 0  # bin count

    # linear scan, presume nothing about values/binner except that it fits ok
    for i in range(0, lenbin - 1):
        r_bin = binner[i + 1]

        # count values in current bin, advance to next bin
        while j < lenidx and (
            values[j] < r_bin or (closed == "right" and values[j] == r_bin)
        ):
            j += 1

        bins[bc] = j
        bc += 1

    return bins


=======
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
class BaseGrouper:
    """
    This is an internal Grouper class, which actually holds
    the generated groups

    Parameters
    ----------
<<<<<<< HEAD
    axis : int
        the axis to group
    groupings : array of grouping
        all the grouping instances to handle in this grouper
        for example for grouper list to groupby, need to pass the list
    sort : boolean, default True
        whether this grouper will give sorted result or not
    group_keys : boolean, default True
    mutated : boolean, default False
=======
    axis : Index
    groupings : Sequence[Grouping]
        all the grouping instances to handle in this grouper
        for example for grouper list to groupby, need to pass the list
    sort : bool, default True
        whether this grouper will give sorted result or not
    group_keys : bool, default True
    mutated : bool, default False
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    indexer : intp array, optional
        the indexer created by Grouper
        some groupers (TimeGrouper) will sort its axis and its
        group_info is also sorted, so need the indexer to reorder

    """

    def __init__(
<<<<<<< HEAD
        self, axis, groupings, sort=True, group_keys=True, mutated=False, indexer=None
    ):
        self._filter_empty_groups = self.compressed = len(groupings) != 1
        self.axis = axis
        self.groupings = groupings
=======
        self,
        axis: Index,
        groupings: "Sequence[grouper.Grouping]",
        sort: bool = True,
        group_keys: bool = True,
        mutated: bool = False,
        indexer: Optional[np.ndarray] = None,
    ):
        assert isinstance(axis, Index), axis

        self._filter_empty_groups = self.compressed = len(groupings) != 1
        self.axis = axis
        self._groupings: List[grouper.Grouping] = list(groupings)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        self.sort = sort
        self.group_keys = group_keys
        self.mutated = mutated
        self.indexer = indexer

    @property
<<<<<<< HEAD
=======
    def groupings(self) -> List["grouper.Grouping"]:
        return self._groupings

    @property
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    def shape(self):
        return tuple(ping.ngroups for ping in self.groupings)

    def __iter__(self):
        return iter(self.indices)

    @property
<<<<<<< HEAD
    def nkeys(self):
        return len(self.groupings)

    def get_iterator(self, data, axis=0):
=======
    def nkeys(self) -> int:
        return len(self.groupings)

    def get_iterator(self, data: FrameOrSeries, axis: int = 0):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        """
        Groupby iterator

        Returns
        -------
        Generator yielding sequence of (name, subsetted object)
        for each group
        """
        splitter = self._get_splitter(data, axis=axis)
        keys = self._get_group_keys()
        for key, (i, group) in zip(keys, splitter):
            yield key, group

<<<<<<< HEAD
    def _get_splitter(self, data, axis=0):
=======
    def _get_splitter(self, data: FrameOrSeries, axis: int = 0) -> "DataSplitter":
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        comp_ids, _, ngroups = self.group_info
        return get_splitter(data, comp_ids, ngroups, axis=axis)

    def _get_grouper(self):
        """
        We are a grouper as part of another's groupings.

        We have a specific method of grouping, so cannot
        convert to a Index for our grouper.
        """
        return self.groupings[0].grouper

    def _get_group_keys(self):
        if len(self.groupings) == 1:
            return self.levels[0]
        else:
            comp_ids, _, ngroups = self.group_info

            # provide "flattened" iterator for multi-group setting
<<<<<<< HEAD
            return get_flattened_iterator(comp_ids, ngroups, self.levels, self.labels)

    def apply(self, f, data, axis=0):
=======
            return get_flattened_iterator(comp_ids, ngroups, self.levels, self.codes)

    def apply(self, f, data: FrameOrSeries, axis: int = 0):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        mutated = self.mutated
        splitter = self._get_splitter(data, axis=axis)
        group_keys = self._get_group_keys()
        result_values = None

<<<<<<< HEAD
        # oh boy
        f_name = com.get_callable_name(f)
        if (
            f_name not in base.plotting_methods
            and hasattr(splitter, "fast_apply")
            and axis == 0
=======
        sdata: FrameOrSeries = splitter._get_sorted_data()
        if sdata.ndim == 2 and np.any(sdata.dtypes.apply(is_extension_array_dtype)):
            # calling splitter.fast_apply will raise TypeError via apply_frame_axis0
            #  if we pass EA instead of ndarray
            #  TODO: can we have a workaround for EAs backed by ndarray?
            pass

        elif (
            com.get_callable_name(f) not in base.plotting_methods
            and isinstance(splitter, FrameSplitter)
            and axis == 0
            # fast_apply/libreduction doesn't allow non-numpy backed indexes
            and not sdata.index._has_complex_internals
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        ):
            try:
                result_values, mutated = splitter.fast_apply(f, group_keys)

<<<<<<< HEAD
=======
            except libreduction.InvalidApply as err:
                # This Exception is raised if `f` triggers an exception
                # but it is preferable to raise the exception in Python.
                if "Let this error raise above us" not in str(err):
                    # TODO: can we infer anything about whether this is
                    #  worth-retrying in pure-python?
                    raise

            else:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
                # If the fast apply path could be used we can return here.
                # Otherwise we need to fall back to the slow implementation.
                if len(result_values) == len(group_keys):
                    return group_keys, result_values, mutated

<<<<<<< HEAD
            except reduction.InvalidApply:
                # Cannot fast apply on MultiIndex (_has_complex_internals).
                # This Exception is also raised if `f` triggers an exception
                # but it is preferable to raise the exception in Python.
                pass
            except Exception:
                # raise this error to the caller
                pass

=======
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        for key, (i, group) in zip(group_keys, splitter):
            object.__setattr__(group, "name", key)

            # result_values is None if fast apply path wasn't taken
            # or fast apply aborted with an unexpected exception.
            # In either case, initialize the result list and perform
            # the slow iteration.
            if result_values is None:
                result_values = []

            # If result_values is not None we're in the case that the
            # fast apply loop was broken prematurely but we have
            # already the result for the first group which we can reuse.
            elif i == 0:
                continue

            # group might be modified
<<<<<<< HEAD
            group_axes = _get_axes(group)
=======
            group_axes = group.axes
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            res = f(group)
            if not _is_indexed_like(res, group_axes):
                mutated = True
            result_values.append(res)

        return group_keys, result_values, mutated

    @cache_readonly
    def indices(self):
        """ dict {group name -> group indices} """
        if len(self.groupings) == 1:
            return self.groupings[0].indices
        else:
<<<<<<< HEAD
            label_list = [ping.labels for ping in self.groupings]
            keys = [com.values_from_object(ping.group_index) for ping in self.groupings]
            return get_indexer_dict(label_list, keys)

    @property
    def labels(self):
        return [ping.labels for ping in self.groupings]

    @property
    def levels(self):
=======
            codes_list = [ping.codes for ping in self.groupings]
            keys = [com.values_from_object(ping.group_index) for ping in self.groupings]
            return get_indexer_dict(codes_list, keys)

    @property
    def codes(self) -> List[np.ndarray]:
        return [ping.codes for ping in self.groupings]

    @property
    def levels(self) -> List[Index]:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return [ping.group_index for ping in self.groupings]

    @property
    def names(self):
        return [ping.name for ping in self.groupings]

<<<<<<< HEAD
    def size(self):
        """
        Compute group sizes

=======
    def size(self) -> Series:
        """
        Compute group sizes.
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        """
        ids, _, ngroup = self.group_info
        ids = ensure_platform_int(ids)
        if ngroup:
            out = np.bincount(ids[ids != -1], minlength=ngroup)
        else:
            out = []
        return Series(out, index=self.result_index, dtype="int64")

    @cache_readonly
    def groups(self):
        """ dict {group name -> group labels} """
        if len(self.groupings) == 1:
            return self.groupings[0].groups
        else:
            to_groupby = zip(*(ping.grouper for ping in self.groupings))
            to_groupby = Index(to_groupby)
            return self.axis.groupby(to_groupby)

    @cache_readonly
<<<<<<< HEAD
    def is_monotonic(self):
=======
    def is_monotonic(self) -> bool:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        # return if my group orderings are monotonic
        return Index(self.group_info[0]).is_monotonic

    @cache_readonly
    def group_info(self):
<<<<<<< HEAD
        comp_ids, obs_group_ids = self._get_compressed_labels()
=======
        comp_ids, obs_group_ids = self._get_compressed_codes()
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        ngroups = len(obs_group_ids)
        comp_ids = ensure_int64(comp_ids)
        return comp_ids, obs_group_ids, ngroups

    @cache_readonly
<<<<<<< HEAD
    def label_info(self):
        # return the labels of items in original grouped axis
        labels, _, _ = self.group_info
        if self.indexer is not None:
            sorter = np.lexsort((labels, self.indexer))
            labels = labels[sorter]
        return labels

    def _get_compressed_labels(self):
        all_labels = [ping.labels for ping in self.groupings]
        if len(all_labels) > 1:
            group_index = get_group_index(all_labels, self.shape, sort=True, xnull=True)
            return compress_group_index(group_index, sort=self.sort)

        ping = self.groupings[0]
        return ping.labels, np.arange(len(ping.group_index))

    @cache_readonly
    def ngroups(self):
        return len(self.result_index)

    @property
    def recons_labels(self):
        comp_ids, obs_ids, _ = self.group_info
        labels = (ping.labels for ping in self.groupings)
        return decons_obs_group_ids(comp_ids, obs_ids, self.shape, labels, xnull=True)

    @cache_readonly
    def result_index(self):
        if not self.compressed and len(self.groupings) == 1:
            return self.groupings[0].result_index.rename(self.names[0])

        codes = self.recons_labels
=======
    def codes_info(self) -> np.ndarray:
        # return the codes of items in original grouped axis
        codes, _, _ = self.group_info
        if self.indexer is not None:
            sorter = np.lexsort((codes, self.indexer))
            codes = codes[sorter]
        return codes

    def _get_compressed_codes(self) -> Tuple[np.ndarray, np.ndarray]:
        all_codes = self.codes
        if len(all_codes) > 1:
            group_index = get_group_index(all_codes, self.shape, sort=True, xnull=True)
            return compress_group_index(group_index, sort=self.sort)

        ping = self.groupings[0]
        return ping.codes, np.arange(len(ping.group_index))

    @cache_readonly
    def ngroups(self) -> int:
        return len(self.result_index)

    @property
    def reconstructed_codes(self) -> List[np.ndarray]:
        codes = self.codes
        comp_ids, obs_ids, _ = self.group_info
        return decons_obs_group_ids(comp_ids, obs_ids, self.shape, codes, xnull=True)

    @cache_readonly
    def result_index(self) -> Index:
        if not self.compressed and len(self.groupings) == 1:
            return self.groupings[0].result_index.rename(self.names[0])

        codes = self.reconstructed_codes
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        levels = [ping.result_index for ping in self.groupings]
        result = MultiIndex(
            levels=levels, codes=codes, verify_integrity=False, names=self.names
        )
        return result

    def get_group_levels(self):
        if not self.compressed and len(self.groupings) == 1:
            return [self.groupings[0].result_index]

        name_list = []
<<<<<<< HEAD
        for ping, labels in zip(self.groupings, self.recons_labels):
            labels = ensure_platform_int(labels)
            levels = ping.result_index.take(labels)
=======
        for ping, codes in zip(self.groupings, self.reconstructed_codes):
            codes = ensure_platform_int(codes)
            levels = ping.result_index.take(codes)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

            name_list.append(levels)

        return name_list

    # ------------------------------------------------------------
    # Aggregation functions

    _cython_functions = {
        "aggregate": {
            "add": "group_add",
            "prod": "group_prod",
            "min": "group_min",
            "max": "group_max",
            "mean": "group_mean",
<<<<<<< HEAD
            "median": {"name": "group_median"},
            "var": "group_var",
            "first": {
                "name": "group_nth",
                "f": lambda func, a, b, c, d, e: func(a, b, c, d, 1, -1),
            },
=======
            "median": "group_median",
            "var": "group_var",
            "first": "group_nth",
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            "last": "group_last",
            "ohlc": "group_ohlc",
        },
        "transform": {
            "cumprod": "group_cumprod",
            "cumsum": "group_cumsum",
            "cummin": "group_cummin",
            "cummax": "group_cummax",
<<<<<<< HEAD
            "rank": {
                "name": "group_rank",
                "f": lambda func, a, b, c, d, e, **kwargs: func(
                    a,
                    b,
                    c,
                    e,
                    kwargs.get("ties_method", "average"),
                    kwargs.get("ascending", True),
                    kwargs.get("pct", False),
                    kwargs.get("na_option", "keep"),
                ),
            },
=======
            "rank": "group_rank",
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        },
    }

    _cython_arity = {"ohlc": 4}  # OHLC

<<<<<<< HEAD
    _name_functions = {"ohlc": lambda *args: ["open", "high", "low", "close"]}
=======
    _name_functions = {"ohlc": ["open", "high", "low", "close"]}
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    def _is_builtin_func(self, arg):
        """
        if we define an builtin function for this argument, return it,
        otherwise return the arg
        """
        return SelectionMixin._builtin_table.get(arg, arg)

<<<<<<< HEAD
    def _get_cython_function(self, kind, how, values, is_numeric):

        dtype_str = values.dtype.name

        def get_func(fname):
            # see if there is a fused-type version of function
            # only valid for numeric
            f = getattr(libgroupby, fname, None)
            if f is not None and is_numeric:
                return f

            # otherwise find dtype-specific version, falling back to object
            for dt in [dtype_str, "object"]:
                f = getattr(
                    libgroupby,
                    "{fname}_{dtype_str}".format(fname=fname, dtype_str=dt),
                    None,
                )
                if f is not None:
                    return f

        ftype = self._cython_functions[kind][how]

        if isinstance(ftype, dict):
            func = afunc = get_func(ftype["name"])

            # a sub-function
            f = ftype.get("f")
            if f is not None:

                def wrapper(*args, **kwargs):
                    return f(afunc, *args, **kwargs)

                # need to curry our sub-function
                func = wrapper

        else:
            func = get_func(ftype)

        if func is None:
            raise NotImplementedError(
                "function is not implemented for this dtype: "
                "[how->{how},dtype->{dtype_str}]".format(how=how, dtype_str=dtype_str)
=======
    def _get_cython_function(self, kind: str, how: str, values, is_numeric: bool):

        dtype_str = values.dtype.name
        ftype = self._cython_functions[kind][how]

        # see if there is a fused-type version of function
        # only valid for numeric
        f = getattr(libgroupby, ftype, None)
        if f is not None and is_numeric:
            return f

        # otherwise find dtype-specific version, falling back to object
        for dt in [dtype_str, "object"]:
            f2 = getattr(libgroupby, f"{ftype}_{dt}", None)
            if f2 is not None:
                return f2

        if hasattr(f, "__signatures__"):
            # inspect what fused types are implemented
            if dtype_str == "object" and "object" not in f.__signatures__:
                # disallow this function so we get a NotImplementedError below
                #  instead of a TypeError at runtime
                f = None

        func = f

        if func is None:
            raise NotImplementedError(
                f"function is not implemented for this dtype: "
                f"[how->{how},dtype->{dtype_str}]"
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            )

        return func

<<<<<<< HEAD
    def _cython_operation(self, kind, values, how, axis, min_count=-1, **kwargs):
        assert kind in ["transform", "aggregate"]
=======
    def _get_cython_func_and_vals(
        self, kind: str, how: str, values: np.ndarray, is_numeric: bool
    ):
        """
        Find the appropriate cython function, casting if necessary.

        Parameters
        ----------
        kind : sttr
        how : srt
        values : np.ndarray
        is_numeric : bool

        Returns
        -------
        func : callable
        values : np.ndarray
        """
        try:
            func = self._get_cython_function(kind, how, values, is_numeric)
        except NotImplementedError:
            if is_numeric:
                try:
                    values = ensure_float64(values)
                except TypeError:
                    if lib.infer_dtype(values, skipna=False) == "complex":
                        values = values.astype(complex)
                    else:
                        raise
                func = self._get_cython_function(kind, how, values, is_numeric)
            else:
                raise
        return func, values

    def _cython_operation(
        self, kind: str, values, how: str, axis, min_count: int = -1, **kwargs
    ) -> Tuple[np.ndarray, Optional[List[str]]]:
        """
        Returns the values of a cython operation as a Tuple of [data, names].

        Names is only useful when dealing with 2D results, like ohlc
        (see self._name_functions).
        """

        assert kind in ["transform", "aggregate"]
        orig_values = values

        if values.ndim > 2:
            raise NotImplementedError("number of dimensions is currently limited to 2")
        elif values.ndim == 2:
            # Note: it is *not* the case that axis is always 0 for 1-dim values,
            #  as we can have 1D ExtensionArrays that we need to treat as 2D
            assert axis == 1, axis
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        # can we do this operation with our cython functions
        # if not raise NotImplementedError

        # we raise NotImplemented if this is an invalid operation
        # entirely, e.g. adding datetimes

        # categoricals are only 1d, so we
        # are not setup for dim transforming
        if is_categorical_dtype(values) or is_sparse(values):
<<<<<<< HEAD
            raise NotImplementedError(
                "{} are not support in cython ops".format(values.dtype)
            )
        elif is_datetime64_any_dtype(values):
            if how in ["add", "prod", "cumsum", "cumprod"]:
                raise NotImplementedError(
                    "datetime64 type does not support {} " "operations".format(how)
=======
            raise NotImplementedError(f"{values.dtype} dtype not supported")
        elif is_datetime64_any_dtype(values):
            if how in ["add", "prod", "cumsum", "cumprod"]:
                raise NotImplementedError(
                    f"datetime64 type does not support {how} operations"
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
                )
        elif is_timedelta64_dtype(values):
            if how in ["prod", "cumprod"]:
                raise NotImplementedError(
<<<<<<< HEAD
                    "timedelta64 type does not support {} " "operations".format(how)
                )

        arity = self._cython_arity.get(how, 1)

        vdim = values.ndim
        swapped = False
        if vdim == 1:
            values = values[:, None]
            out_shape = (self.ngroups, arity)
        else:
            if axis > 0:
                swapped = True
                assert axis == 1, axis
                values = values.T
            if arity > 1:
                raise NotImplementedError(
                    "arity of more than 1 is not " "supported for the 'how' argument"
                )
            out_shape = (self.ngroups,) + values.shape[1:]
=======
                    f"timedelta64 type does not support {how} operations"
                )

        if is_datetime64tz_dtype(values.dtype):
            # Cast to naive; we'll cast back at the end of the function
            # TODO: possible need to reshape?  kludge can be avoided when
            #  2D EA is allowed.
            values = values.view("M8[ns]")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        is_datetimelike = needs_i8_conversion(values.dtype)
        is_numeric = is_numeric_dtype(values.dtype)

        if is_datetimelike:
            values = values.view("int64")
            is_numeric = True
        elif is_bool_dtype(values.dtype):
            values = ensure_float64(values)
        elif is_integer_dtype(values):
            # we use iNaT for the missing value on ints
            # so pre-convert to guard this condition
            if (values == iNaT).any():
                values = ensure_float64(values)
            else:
                values = ensure_int_or_float(values)
        elif is_numeric and not is_complex_dtype(values):
            values = ensure_float64(values)
        else:
            values = values.astype(object)

<<<<<<< HEAD
        try:
            func = self._get_cython_function(kind, how, values, is_numeric)
        except NotImplementedError:
            if is_numeric:
                values = ensure_float64(values)
                func = self._get_cython_function(kind, how, values, is_numeric)
            else:
                raise
=======
        arity = self._cython_arity.get(how, 1)

        vdim = values.ndim
        swapped = False
        if vdim == 1:
            values = values[:, None]
            out_shape = (self.ngroups, arity)
        else:
            if axis > 0:
                swapped = True
                assert axis == 1, axis
                values = values.T
            if arity > 1:
                raise NotImplementedError(
                    "arity of more than 1 is not supported for the 'how' argument"
                )
            out_shape = (self.ngroups,) + values.shape[1:]

        func, values = self._get_cython_func_and_vals(kind, how, values, is_numeric)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        if how == "rank":
            out_dtype = "float"
        else:
            if is_numeric:
<<<<<<< HEAD
                out_dtype = "{kind}{itemsize}".format(
                    kind=values.dtype.kind, itemsize=values.dtype.itemsize
                )
            else:
                out_dtype = "object"

        labels, _, _ = self.group_info
=======
                out_dtype = f"{values.dtype.kind}{values.dtype.itemsize}"
            else:
                out_dtype = "object"

        codes, _, _ = self.group_info
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        if kind == "aggregate":
            result = _maybe_fill(
                np.empty(out_shape, dtype=out_dtype), fill_value=np.nan
            )
            counts = np.zeros(self.ngroups, dtype=np.int64)
            result = self._aggregate(
<<<<<<< HEAD
                result,
                counts,
                values,
                labels,
                func,
                is_numeric,
                is_datetimelike,
                min_count,
=======
                result, counts, values, codes, func, is_datetimelike, min_count
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            )
        elif kind == "transform":
            result = _maybe_fill(
                np.empty_like(values, dtype=out_dtype), fill_value=np.nan
            )

            # TODO: min_count
            result = self._transform(
<<<<<<< HEAD
                result, values, labels, func, is_numeric, is_datetimelike, **kwargs
=======
                result, values, codes, func, is_datetimelike, **kwargs
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            )

        if is_integer_dtype(result) and not is_datetimelike:
            mask = result == iNaT
            if mask.any():
                result = result.astype("float64")
                result[mask] = np.nan
<<<<<<< HEAD

        if kind == "aggregate" and self._filter_empty_groups and not counts.all():
            if result.ndim == 2:
                try:
                    result = lib.row_bool_subset(result, (counts > 0).view(np.uint8))
                except ValueError:
                    result = lib.row_bool_subset_object(
                        ensure_object(result), (counts > 0).view(np.uint8)
                    )
            else:
                result = result[counts > 0]
=======
        elif (
            how == "add"
            and is_integer_dtype(orig_values.dtype)
            and is_extension_array_dtype(orig_values.dtype)
        ):
            # We need this to ensure that Series[Int64Dtype].resample().sum()
            # remains int64 dtype.
            # Two options for avoiding this special case
            # 1. mask-aware ops and avoid casting to float with NaN above
            # 2. specify the result dtype when calling this method
            result = result.astype("int64")

        if kind == "aggregate" and self._filter_empty_groups and not counts.all():
            assert result.ndim != 2
            result = result[counts > 0]
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        if vdim == 1 and arity == 1:
            result = result[:, 0]

<<<<<<< HEAD
        if how in self._name_functions:
            # TODO
            names = self._name_functions[how]()
        else:
            names = None
=======
        names: Optional[List[str]] = self._name_functions.get(how, None)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        if swapped:
            result = result.swapaxes(0, axis)

<<<<<<< HEAD
        return result, names

    def aggregate(self, values, how, axis=0, min_count=-1):
=======
        if is_datetime64tz_dtype(orig_values.dtype) or is_period_dtype(
            orig_values.dtype
        ):
            # We need to use the constructors directly for these dtypes
            # since numpy won't recognize them
            # https://github.com/pandas-dev/pandas/issues/31471
            result = type(orig_values)(result.astype(np.int64), dtype=orig_values.dtype)
        elif is_datetimelike and kind == "aggregate":
            result = result.astype(orig_values.dtype)

        return result, names

    def aggregate(
        self, values, how: str, axis: int = 0, min_count: int = -1
    ) -> Tuple[np.ndarray, Optional[List[str]]]:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return self._cython_operation(
            "aggregate", values, how, axis, min_count=min_count
        )

<<<<<<< HEAD
    def transform(self, values, how, axis=0, **kwargs):
=======
    def transform(self, values, how: str, axis: int = 0, **kwargs):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return self._cython_operation("transform", values, how, axis, **kwargs)

    def _aggregate(
        self,
        result,
        counts,
        values,
        comp_ids,
        agg_func,
<<<<<<< HEAD
        is_numeric,
        is_datetimelike,
        min_count=-1,
    ):
        if values.ndim > 3:
            # punting for now
            raise NotImplementedError(
                "number of dimensions is currently " "limited to 3"
            )
        elif values.ndim > 2:
            for i, chunk in enumerate(values.transpose(2, 0, 1)):

                chunk = chunk.squeeze()
                agg_func(result[:, :, i], counts, chunk, comp_ids, min_count)
=======
        is_datetimelike: bool,
        min_count: int = -1,
    ):
        if agg_func is libgroupby.group_nth:
            # different signature from the others
            # TODO: should we be using min_count instead of hard-coding it?
            agg_func(result, counts, values, comp_ids, rank=1, min_count=-1)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        else:
            agg_func(result, counts, values, comp_ids, min_count)

        return result

    def _transform(
<<<<<<< HEAD
        self,
        result,
        values,
        comp_ids,
        transform_func,
        is_numeric,
        is_datetimelike,
        **kwargs
    ):

        comp_ids, _, ngroups = self.group_info
        if values.ndim > 3:
            # punting for now
            raise NotImplementedError(
                "number of dimensions is currently " "limited to 3"
            )
        elif values.ndim > 2:
            for i, chunk in enumerate(values.transpose(2, 0, 1)):

                transform_func(
                    result[:, :, i],
                    values,
                    comp_ids,
                    ngroups,
                    is_datetimelike,
                    **kwargs
                )
        else:
            transform_func(result, values, comp_ids, ngroups, is_datetimelike, **kwargs)

        return result

    def agg_series(self, obj, func):
        try:
            return self._aggregate_series_fast(obj, func)
        except Exception:
            return self._aggregate_series_pure_python(obj, func)

    def _aggregate_series_fast(self, obj, func):
        func = self._is_builtin_func(func)

        if obj.index._has_complex_internals:
            raise TypeError("Incompatible index for Cython grouper")
=======
        self, result, values, comp_ids, transform_func, is_datetimelike: bool, **kwargs
    ):

        comp_ids, _, ngroups = self.group_info
        transform_func(result, values, comp_ids, ngroups, is_datetimelike, **kwargs)

        return result

    def agg_series(self, obj: Series, func):
        # Caller is responsible for checking ngroups != 0
        assert self.ngroups != 0

        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            return self._aggregate_series_pure_python(obj, func)

        elif is_extension_array_dtype(obj.dtype):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            return self._aggregate_series_pure_python(obj, func)

        elif obj.index._has_complex_internals:
            # Pre-empt TypeError in _aggregate_series_fast
            return self._aggregate_series_pure_python(obj, func)

        try:
            return self._aggregate_series_fast(obj, func)
        except ValueError as err:
            if "Function does not reduce" in str(err):
                # raised in libreduction
                pass
            else:
                raise
        return self._aggregate_series_pure_python(obj, func)

    def _aggregate_series_fast(self, obj: Series, func):
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        #  - ngroups != 0
        func = self._is_builtin_func(func)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        group_index, _, ngroups = self.group_info

        # avoids object / Series creation overhead
        dummy = obj._get_values(slice(None, 0))
        indexer = get_group_index_sorter(group_index, ngroups)
        obj = obj.take(indexer)
        group_index = algorithms.take_nd(group_index, indexer, allow_fill=False)
<<<<<<< HEAD
        grouper = reduction.SeriesGrouper(obj, func, group_index, ngroups, dummy)
        result, counts = grouper.get_result()
        return result, counts

    def _aggregate_series_pure_python(self, obj, func):
=======
        grouper = libreduction.SeriesGrouper(obj, func, group_index, ngroups, dummy)
        result, counts = grouper.get_result()
        return result, counts

    def _aggregate_series_pure_python(self, obj: Series, func):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        group_index, _, ngroups = self.group_info

        counts = np.zeros(ngroups, dtype=int)
        result = None

<<<<<<< HEAD
        splitter = get_splitter(obj, group_index, ngroups, axis=self.axis)
=======
        splitter = get_splitter(obj, group_index, ngroups, axis=0)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        for label, group in splitter:
            res = func(group)
            if result is None:
                if isinstance(res, (Series, Index, np.ndarray)):
<<<<<<< HEAD
                    raise ValueError("Function does not reduce")
=======
                    if len(res) == 1:
                        # e.g. test_agg_lambda_with_timezone lambda e: e.head(1)
                        # FIXME: are we potentially losing import res.index info?
                        res = res.item()
                    else:
                        raise ValueError("Function does not reduce")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
                result = np.empty(ngroups, dtype="O")

            counts[label] = group.shape[0]
            result[label] = res

<<<<<<< HEAD
        result = lib.maybe_convert_objects(result, try_float=0)
=======
        assert result is not None
        result = lib.maybe_convert_objects(result, try_float=0)
        # TODO: try_cast back to EA?

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return result, counts


class BinGrouper(BaseGrouper):
<<<<<<< HEAD

=======
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    """
    This is an internal Grouper class

    Parameters
    ----------
    bins : the split index of binlabels to group the item of axis
    binlabels : the label list
    filter_empty : boolean, default False
    mutated : boolean, default False
    indexer : a intp array

    Examples
    --------
    bins: [2, 4, 6, 8, 10]
    binlabels: DatetimeIndex(['2005-01-01', '2005-01-03',
        '2005-01-05', '2005-01-07', '2005-01-09'],
        dtype='datetime64[ns]', freq='2D')

    the group_info, which contains the label of each item in grouped
    axis, the index of label in label list, group number, is

    (array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4]), array([0, 1, 2, 3, 4]), 5)

    means that, the grouped axis has 10 items, can be grouped into 5
    labels, the first and second items belong to the first label, the
    third and forth items belong to the second label, and so on

    """

    def __init__(
<<<<<<< HEAD
        self, bins, binlabels, filter_empty=False, mutated=False, indexer=None
=======
        self,
        bins,
        binlabels,
        filter_empty: bool = False,
        mutated: bool = False,
        indexer=None,
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    ):
        self.bins = ensure_int64(bins)
        self.binlabels = ensure_index(binlabels)
        self._filter_empty_groups = filter_empty
        self.mutated = mutated
        self.indexer = indexer

<<<<<<< HEAD
=======
        # These lengths must match, otherwise we could call agg_series
        #  with empty self.bins, which would raise in libreduction.
        assert len(self.binlabels) == len(self.bins)

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    @cache_readonly
    def groups(self):
        """ dict {group name -> group labels} """

        # this is mainly for compat
        # GH 3881
        result = {
            key: value
            for key, value in zip(self.binlabels, self.bins)
            if key is not NaT
        }
        return result

    @property
<<<<<<< HEAD
    def nkeys(self):
=======
    def nkeys(self) -> int:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return 1

    def _get_grouper(self):
        """
        We are a grouper as part of another's groupings.

        We have a specific method of grouping, so cannot
        convert to a Index for our grouper.
        """
        return self

<<<<<<< HEAD
    def get_iterator(self, data, axis=0):
=======
    def get_iterator(self, data: FrameOrSeries, axis: int = 0):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        """
        Groupby iterator

        Returns
        -------
        Generator yielding sequence of (name, subsetted object)
        for each group
        """
<<<<<<< HEAD
        if isinstance(data, NDFrame):
            slicer = lambda start, edge: data._slice(slice(start, edge), axis=axis)
            length = len(data.axes[axis])
        else:
            slicer = lambda start, edge: data[slice(start, edge)]
            length = len(data)
=======
        slicer = lambda start, edge: data._slice(slice(start, edge), axis=axis)
        length = len(data.axes[axis])
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        start = 0
        for edge, label in zip(self.bins, self.binlabels):
            if label is not NaT:
                yield label, slicer(start, edge)
            start = edge

        if start < length:
            yield self.binlabels[-1], slicer(start, None)

    @cache_readonly
    def indices(self):
        indices = collections.defaultdict(list)

        i = 0
        for label, bin in zip(self.binlabels, self.bins):
            if i < bin:
                if label is not NaT:
                    indices[label] = list(range(i, bin))
                i = bin
        return indices

    @cache_readonly
    def group_info(self):
        ngroups = self.ngroups
        obs_group_ids = np.arange(ngroups)
        rep = np.diff(np.r_[0, self.bins])

        rep = ensure_platform_int(rep)
        if ngroups == len(self.bins):
            comp_ids = np.repeat(np.arange(ngroups), rep)
        else:
            comp_ids = np.repeat(np.r_[-1, np.arange(ngroups)], rep)

        return (
            comp_ids.astype("int64", copy=False),
            obs_group_ids.astype("int64", copy=False),
            ngroups,
        )

    @cache_readonly
<<<<<<< HEAD
=======
    def reconstructed_codes(self) -> List[np.ndarray]:
        # get unique result indices, and prepend 0 as groupby starts from the first
        return [np.r_[0, np.flatnonzero(self.bins[1:] != self.bins[:-1]) + 1]]

    @cache_readonly
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    def result_index(self):
        if len(self.binlabels) != 0 and isna(self.binlabels[0]):
            return self.binlabels[1:]

        return self.binlabels

    @property
    def levels(self):
        return [self.binlabels]

    @property
    def names(self):
        return [self.binlabels.name]

    @property
<<<<<<< HEAD
    def groupings(self):
        from pandas.core.groupby.grouper import Grouping

        return [
            Grouping(lvl, lvl, in_axis=False, level=None, name=name)
            for lvl, name in zip(self.levels, self.names)
        ]

    def agg_series(self, obj, func):
        dummy = obj[:0]
        grouper = reduction.SeriesBinGrouper(obj, func, self.bins, dummy)
        return grouper.get_result()


def _get_axes(group):
    if isinstance(group, Series):
        return [group.index]
    else:
        return group.axes


def _is_indexed_like(obj, axes):
=======
    def groupings(self) -> "List[grouper.Grouping]":
        return [
            grouper.Grouping(lvl, lvl, in_axis=False, level=None, name=name)
            for lvl, name in zip(self.levels, self.names)
        ]

    def agg_series(self, obj: Series, func):
        # Caller is responsible for checking ngroups != 0
        assert self.ngroups != 0
        assert len(self.bins) > 0  # otherwise we'd get IndexError in get_result

        if is_extension_array_dtype(obj.dtype):
            # pre-empt SeriesBinGrouper from raising TypeError
            return self._aggregate_series_pure_python(obj, func)

        dummy = obj[:0]
        grouper = libreduction.SeriesBinGrouper(obj, func, self.bins, dummy)
        return grouper.get_result()


def _is_indexed_like(obj, axes) -> bool:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    if isinstance(obj, Series):
        if len(axes) > 1:
            return False
        return obj.index.equals(axes[0])
    elif isinstance(obj, DataFrame):
        return obj.index.equals(axes[0])

    return False


# ----------------------------------------------------------------------
# Splitting / application


class DataSplitter:
<<<<<<< HEAD
    def __init__(self, data, labels, ngroups, axis=0):
=======
    def __init__(self, data: FrameOrSeries, labels, ngroups: int, axis: int = 0):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        self.data = data
        self.labels = ensure_int64(labels)
        self.ngroups = ngroups

        self.axis = axis
<<<<<<< HEAD
=======
        assert isinstance(axis, int), axis
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    @cache_readonly
    def slabels(self):
        # Sorted labels
        return algorithms.take_nd(self.labels, self.sort_idx, allow_fill=False)

    @cache_readonly
    def sort_idx(self):
        # Counting sort indexer
        return get_group_index_sorter(self.labels, self.ngroups)

    def __iter__(self):
        sdata = self._get_sorted_data()

        if self.ngroups == 0:
            # we are inside a generator, rather than raise StopIteration
            # we merely return signal the end
            return

        starts, ends = lib.generate_slices(self.slabels, self.ngroups)

        for i, (start, end) in enumerate(zip(starts, ends)):
<<<<<<< HEAD
            # Since I'm now compressing the group ids, it's now not "possible"
            # to produce empty slices because such groups would not be observed
            # in the data
            # if start >= end:
            #     raise AssertionError('Start %s must be less than end %s'
            #                          % (str(start), str(end)))
            yield i, self._chop(sdata, slice(start, end))

    def _get_sorted_data(self):
        return self.data.take(self.sort_idx, axis=self.axis)

    def _chop(self, sdata, slice_obj):
        return sdata.iloc[slice_obj]

    def apply(self, f):
=======
            yield i, self._chop(sdata, slice(start, end))

    def _get_sorted_data(self) -> FrameOrSeries:
        return self.data.take(self.sort_idx, axis=self.axis)

    def _chop(self, sdata, slice_obj: slice) -> NDFrame:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        raise AbstractMethodError(self)


class SeriesSplitter(DataSplitter):
<<<<<<< HEAD
    def _chop(self, sdata, slice_obj):
=======
    def _chop(self, sdata: Series, slice_obj: slice) -> Series:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return sdata._get_values(slice_obj)


class FrameSplitter(DataSplitter):
    def fast_apply(self, f, names):
        # must return keys::list, values::list, mutated::bool
<<<<<<< HEAD
        try:
            starts, ends = lib.generate_slices(self.slabels, self.ngroups)
        except Exception:
            # fails when all -1
            return [], True

        sdata = self._get_sorted_data()
        return reduction.apply_frame_axis0(sdata, f, names, starts, ends)

    def _chop(self, sdata, slice_obj):
        if self.axis == 0:
            return sdata.iloc[slice_obj]
        else:
            return sdata._slice(slice_obj, axis=1)  # .loc[:, slice_obj]


def get_splitter(data, *args, **kwargs):
    if isinstance(data, Series):
        klass = SeriesSplitter
    elif isinstance(data, DataFrame):
=======
        starts, ends = lib.generate_slices(self.slabels, self.ngroups)

        sdata = self._get_sorted_data()
        return libreduction.apply_frame_axis0(sdata, f, names, starts, ends)

    def _chop(self, sdata: DataFrame, slice_obj: slice) -> DataFrame:
        if self.axis == 0:
            return sdata.iloc[slice_obj]
        else:
            return sdata._slice(slice_obj, axis=1)


def get_splitter(data: FrameOrSeries, *args, **kwargs) -> DataSplitter:
    if isinstance(data, Series):
        klass: Type[DataSplitter] = SeriesSplitter
    else:
        # i.e. DataFrame
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        klass = FrameSplitter

    return klass(data, *args, **kwargs)
