"""Core eval alignment algorithms
"""

from functools import partial, wraps
<<<<<<< HEAD
=======
from typing import Dict, Optional, Sequence, Tuple, Type, Union
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
import warnings

import numpy as np

<<<<<<< HEAD
from pandas.errors import PerformanceWarning

import pandas as pd
import pandas.core.common as com
from pandas.core.computation.common import _result_type_many


def _align_core_single_unary_op(term):
=======
from pandas._typing import FrameOrSeries
from pandas.errors import PerformanceWarning

from pandas.core.dtypes.generic import ABCDataFrame, ABCSeries

from pandas.core.base import PandasObject
import pandas.core.common as com
from pandas.core.computation.common import result_type_many


def _align_core_single_unary_op(
    term,
) -> Tuple[Union[partial, Type[FrameOrSeries]], Optional[Dict[str, int]]]:

    typ: Union[partial, Type[FrameOrSeries]]
    axes: Optional[Dict[str, int]] = None

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    if isinstance(term.value, np.ndarray):
        typ = partial(np.asanyarray, dtype=term.value.dtype)
    else:
        typ = type(term.value)
<<<<<<< HEAD
    ret = (typ,)

    if not hasattr(term.value, "axes"):
        ret += (None,)
    else:
        ret += (_zip_axes_from_type(typ, term.value.axes),)
    return ret


def _zip_axes_from_type(typ, new_axes):
    axes = {ax_name: new_axes[ax_ind] for ax_ind, ax_name in typ._AXIS_NAMES.items()}
    return axes


def _any_pandas_objects(terms):
    """Check a sequence of terms for instances of PandasObject."""
    return any(isinstance(term.value, pd.core.generic.PandasObject) for term in terms)
=======
        if hasattr(term.value, "axes"):
            axes = _zip_axes_from_type(typ, term.value.axes)

    return typ, axes


def _zip_axes_from_type(
    typ: Type[FrameOrSeries], new_axes: Sequence[int]
) -> Dict[str, int]:
    axes = {name: new_axes[i] for i, name in typ._AXIS_NAMES.items()}
    return axes


def _any_pandas_objects(terms) -> bool:
    """
    Check a sequence of terms for instances of PandasObject.
    """
    return any(isinstance(term.value, PandasObject) for term in terms)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f


def _filter_special_cases(f):
    @wraps(f)
    def wrapper(terms):
        # single unary operand
        if len(terms) == 1:
            return _align_core_single_unary_op(terms[0])

        term_values = (term.value for term in terms)

        # we don't have any pandas objects
        if not _any_pandas_objects(terms):
<<<<<<< HEAD
            return _result_type_many(*term_values), None
=======
            return result_type_many(*term_values), None
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        return f(terms)

    return wrapper


@_filter_special_cases
def _align_core(terms):
    term_index = [i for i, term in enumerate(terms) if hasattr(term.value, "axes")]
    term_dims = [terms[i].value.ndim for i in term_index]
<<<<<<< HEAD
    ndims = pd.Series(dict(zip(term_index, term_dims)))
=======

    from pandas import Series

    ndims = Series(dict(zip(term_index, term_dims)))
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    # initial axes are the axes of the largest-axis'd term
    biggest = terms[ndims.idxmax()].value
    typ = biggest._constructor
    axes = biggest.axes
    naxes = len(axes)
    gt_than_one_axis = naxes > 1

    for value in (terms[i].value for i in term_index):
<<<<<<< HEAD
        is_series = isinstance(value, pd.Series)
=======
        is_series = isinstance(value, ABCSeries)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        is_series_and_gt_one_axis = is_series and gt_than_one_axis

        for axis, items in enumerate(value.axes):
            if is_series_and_gt_one_axis:
                ax, itm = naxes - 1, value.index
            else:
                ax, itm = axis, items

            if not axes[ax].is_(itm):
                axes[ax] = axes[ax].join(itm, how="outer")

    for i, ndim in ndims.items():
        for axis, items in zip(range(ndim), axes):
            ti = terms[i].value

            if hasattr(ti, "reindex"):
<<<<<<< HEAD
                transpose = isinstance(ti, pd.Series) and naxes > 1
=======
                transpose = isinstance(ti, ABCSeries) and naxes > 1
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
                reindexer = axes[naxes - 1] if transpose else items

                term_axis_size = len(ti.axes[axis])
                reindexer_size = len(reindexer)

                ordm = np.log10(max(1, abs(reindexer_size - term_axis_size)))
                if ordm >= 1 and reindexer_size >= 10000:
                    w = (
<<<<<<< HEAD
                        "Alignment difference on axis {axis} is larger "
                        "than an order of magnitude on term {term!r}, by "
                        "more than {ordm:.4g}; performance may suffer"
                    ).format(axis=axis, term=terms[i].name, ordm=ordm)
=======
                        f"Alignment difference on axis {axis} is larger "
                        f"than an order of magnitude on term {repr(terms[i].name)}, "
                        f"by more than {ordm:.4g}; performance may suffer"
                    )
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
                    warnings.warn(w, category=PerformanceWarning, stacklevel=6)

                f = partial(ti.reindex, reindexer, axis=axis, copy=False)

                terms[i].update(f())

        terms[i].update(terms[i].value.values)

    return typ, _zip_axes_from_type(typ, axes)


<<<<<<< HEAD
def _align(terms):
    """Align a set of terms"""
=======
def align_terms(terms):
    """
    Align a set of terms.
    """
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    try:
        # flatten the parse tree (a nested list, really)
        terms = list(com.flatten(terms))
    except TypeError:
        # can't iterate so it must just be a constant or single variable
<<<<<<< HEAD
        if isinstance(terms.value, pd.core.generic.NDFrame):
=======
        if isinstance(terms.value, (ABCSeries, ABCDataFrame)):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            typ = type(terms.value)
            return typ, _zip_axes_from_type(typ, terms.value.axes)
        return np.result_type(terms.type), None

    # if all resolved variables are numeric scalars
    if all(term.is_scalar for term in terms):
<<<<<<< HEAD
        return _result_type_many(*(term.value for term in terms)).type, None
=======
        return result_type_many(*(term.value for term in terms)).type, None
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    # perform the main alignment
    typ, axes = _align_core(terms)
    return typ, axes


<<<<<<< HEAD
def _reconstruct_object(typ, obj, axes, dtype):
    """Reconstruct an object given its type, raw value, and possibly empty
=======
def reconstruct_object(typ, obj, axes, dtype):
    """
    Reconstruct an object given its type, raw value, and possibly empty
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    (None) axes.

    Parameters
    ----------
    typ : object
        A type
    obj : object
        The value to use in the type constructor
    axes : dict
        The axes to use to construct the resulting pandas object

    Returns
    -------
    ret : typ
        An object of type ``typ`` with the value `obj` and possible axes
        `axes`.
    """
    try:
        typ = typ.type
    except AttributeError:
        pass

    res_t = np.result_type(obj.dtype, dtype)

<<<<<<< HEAD
    if not isinstance(typ, partial) and issubclass(typ, pd.core.generic.PandasObject):
=======
    if not isinstance(typ, partial) and issubclass(typ, PandasObject):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return typ(obj, dtype=res_t, **axes)

    # special case for pathological things like ~True/~False
    if hasattr(res_t, "type") and typ == np.bool_ and res_t != np.bool_:
        ret_value = res_t.type(obj)
    else:
        ret_value = typ(obj).astype(res_t)
        # The condition is to distinguish 0-dim array (returned in case of
        # scalar) and 1 element array
        # e.g. np.array(0) and np.array([0])
        if len(obj.shape) == 1 and len(obj) == 1:
            if not isinstance(ret_value, np.ndarray):
                ret_value = np.array([ret_value]).astype(res_t)

    return ret_value
