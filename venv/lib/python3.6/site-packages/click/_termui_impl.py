# -*- coding: utf-8 -*-
"""
<<<<<<< HEAD
click._termui_impl
~~~~~~~~~~~~~~~~~~

This module contains implementations for the termui module. To keep the
import time of Click down, some infrequently used functionality is
placed in this module and only imported as needed.

:copyright: Â© 2014 by the Pallets team.
:license: BSD, see LICENSE.rst for more details.
"""

import os
import sys
import time
import math
import contextlib
from ._compat import _default_text_stdout, range_type, PY2, isatty, \
     open_stream, strip_ansi, term_len, get_best_encoding, WIN, int_types, \
     CYGWIN
from .utils import echo
from .exceptions import ClickException


if os.name == 'nt':
    BEFORE_BAR = '\r'
    AFTER_BAR = '\n'
else:
    BEFORE_BAR = '\r\033[?25l'
    AFTER_BAR = '\033[?25h\n'
=======
This module contains implementations for the termui module. To keep the
import time of Click down, some infrequently used functionality is
placed in this module and only imported as needed.
"""
import contextlib
import math
import os
import sys
import time

from ._compat import _default_text_stdout
from ._compat import CYGWIN
from ._compat import get_best_encoding
from ._compat import int_types
from ._compat import isatty
from ._compat import open_stream
from ._compat import range_type
from ._compat import shlex_quote
from ._compat import strip_ansi
from ._compat import term_len
from ._compat import WIN
from .exceptions import ClickException
from .utils import echo

if os.name == "nt":
    BEFORE_BAR = "\r"
    AFTER_BAR = "\n"
else:
    BEFORE_BAR = "\r\033[?25l"
    AFTER_BAR = "\033[?25h\n"
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f


def _length_hint(obj):
    """Returns the length hint of an object."""
    try:
        return len(obj)
    except (AttributeError, TypeError):
        try:
            get_hint = type(obj).__length_hint__
        except AttributeError:
            return None
        try:
            hint = get_hint(obj)
        except TypeError:
            return None
<<<<<<< HEAD
        if hint is NotImplemented or \
           not isinstance(hint, int_types) or \
           hint < 0:
=======
        if hint is NotImplemented or not isinstance(hint, int_types) or hint < 0:
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            return None
        return hint


class ProgressBar(object):
<<<<<<< HEAD

    def __init__(self, iterable, length=None, fill_char='#', empty_char=' ',
                 bar_template='%(bar)s', info_sep='  ', show_eta=True,
                 show_percent=None, show_pos=False, item_show_func=None,
                 label=None, file=None, color=None, width=30):
=======
    def __init__(
        self,
        iterable,
        length=None,
        fill_char="#",
        empty_char=" ",
        bar_template="%(bar)s",
        info_sep="  ",
        show_eta=True,
        show_percent=None,
        show_pos=False,
        item_show_func=None,
        label=None,
        file=None,
        color=None,
        width=30,
    ):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        self.fill_char = fill_char
        self.empty_char = empty_char
        self.bar_template = bar_template
        self.info_sep = info_sep
        self.show_eta = show_eta
        self.show_percent = show_percent
        self.show_pos = show_pos
        self.item_show_func = item_show_func
<<<<<<< HEAD
        self.label = label or ''
=======
        self.label = label or ""
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        if file is None:
            file = _default_text_stdout()
        self.file = file
        self.color = color
        self.width = width
        self.autowidth = width == 0

        if length is None:
            length = _length_hint(iterable)
        if iterable is None:
            if length is None:
<<<<<<< HEAD
                raise TypeError('iterable or length is required')
=======
                raise TypeError("iterable or length is required")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            iterable = range_type(length)
        self.iter = iter(iterable)
        self.length = length
        self.length_known = length is not None
        self.pos = 0
        self.avg = []
        self.start = self.last_eta = time.time()
        self.eta_known = False
        self.finished = False
        self.max_width = None
        self.entered = False
        self.current_item = None
        self.is_hidden = not isatty(self.file)
        self._last_line = None
        self.short_limit = 0.5

    def __enter__(self):
        self.entered = True
        self.render_progress()
        return self

    def __exit__(self, exc_type, exc_value, tb):
        self.render_finish()

    def __iter__(self):
        if not self.entered:
<<<<<<< HEAD
            raise RuntimeError('You need to use progress bars in a with block.')
        self.render_progress()
        return self.generator()

=======
            raise RuntimeError("You need to use progress bars in a with block.")
        self.render_progress()
        return self.generator()

    def __next__(self):
        # Iteration is defined in terms of a generator function,
        # returned by iter(self); use that to define next(). This works
        # because `self.iter` is an iterable consumed by that generator,
        # so it is re-entry safe. Calling `next(self.generator())`
        # twice works and does "what you want".
        return next(iter(self))

    # Python 2 compat
    next = __next__

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    def is_fast(self):
        return time.time() - self.start <= self.short_limit

    def render_finish(self):
        if self.is_hidden or self.is_fast():
            return
        self.file.write(AFTER_BAR)
        self.file.flush()

    @property
    def pct(self):
        if self.finished:
            return 1.0
        return min(self.pos / (float(self.length) or 1), 1.0)

    @property
    def time_per_iteration(self):
        if not self.avg:
            return 0.0
        return sum(self.avg) / float(len(self.avg))

    @property
    def eta(self):
        if self.length_known and not self.finished:
            return self.time_per_iteration * (self.length - self.pos)
        return 0.0

    def format_eta(self):
        if self.eta_known:
            t = int(self.eta)
            seconds = t % 60
            t //= 60
            minutes = t % 60
            t //= 60
            hours = t % 24
            t //= 24
            if t > 0:
<<<<<<< HEAD
                days = t
                return '%dd %02d:%02d:%02d' % (days, hours, minutes, seconds)
            else:
                return '%02d:%02d:%02d' % (hours, minutes, seconds)
        return ''
=======
                return "{}d {:02}:{:02}:{:02}".format(t, hours, minutes, seconds)
            else:
                return "{:02}:{:02}:{:02}".format(hours, minutes, seconds)
        return ""
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    def format_pos(self):
        pos = str(self.pos)
        if self.length_known:
<<<<<<< HEAD
            pos += '/%s' % self.length
        return pos

    def format_pct(self):
        return ('% 4d%%' % int(self.pct * 100))[1:]
=======
            pos += "/{}".format(self.length)
        return pos

    def format_pct(self):
        return "{: 4}%".format(int(self.pct * 100))[1:]
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    def format_bar(self):
        if self.length_known:
            bar_length = int(self.pct * self.width)
            bar = self.fill_char * bar_length
            bar += self.empty_char * (self.width - bar_length)
        elif self.finished:
            bar = self.fill_char * self.width
        else:
            bar = list(self.empty_char * (self.width or 1))
            if self.time_per_iteration != 0:
<<<<<<< HEAD
                bar[int((math.cos(self.pos * self.time_per_iteration)
                    / 2.0 + 0.5) * self.width)] = self.fill_char
            bar = ''.join(bar)
=======
                bar[
                    int(
                        (math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)
                        * self.width
                    )
                ] = self.fill_char
            bar = "".join(bar)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return bar

    def format_progress_line(self):
        show_percent = self.show_percent

        info_bits = []
        if self.length_known and show_percent is None:
            show_percent = not self.show_pos

        if self.show_pos:
            info_bits.append(self.format_pos())
        if show_percent:
            info_bits.append(self.format_pct())
        if self.show_eta and self.eta_known and not self.finished:
            info_bits.append(self.format_eta())
        if self.item_show_func is not None:
            item_info = self.item_show_func(self.current_item)
            if item_info is not None:
                info_bits.append(item_info)

<<<<<<< HEAD
        return (self.bar_template % {
            'label': self.label,
            'bar': self.format_bar(),
            'info': self.info_sep.join(info_bits)
        }).rstrip()
=======
        return (
            self.bar_template
            % {
                "label": self.label,
                "bar": self.format_bar(),
                "info": self.info_sep.join(info_bits),
            }
        ).rstrip()
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    def render_progress(self):
        from .termui import get_terminal_size

        if self.is_hidden:
            return

        buf = []
        # Update width in case the terminal has been resized
        if self.autowidth:
            old_width = self.width
            self.width = 0
            clutter_length = term_len(self.format_progress_line())
            new_width = max(0, get_terminal_size()[0] - clutter_length)
            if new_width < old_width:
                buf.append(BEFORE_BAR)
<<<<<<< HEAD
                buf.append(' ' * self.max_width)
=======
                buf.append(" " * self.max_width)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
                self.max_width = new_width
            self.width = new_width

        clear_width = self.width
        if self.max_width is not None:
            clear_width = self.max_width

        buf.append(BEFORE_BAR)
        line = self.format_progress_line()
        line_len = term_len(line)
        if self.max_width is None or self.max_width < line_len:
            self.max_width = line_len

        buf.append(line)
<<<<<<< HEAD
        buf.append(' ' * (clear_width - line_len))
        line = ''.join(buf)
=======
        buf.append(" " * (clear_width - line_len))
        line = "".join(buf)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        # Render the line only if it changed.

        if line != self._last_line and not self.is_fast():
            self._last_line = line
            echo(line, file=self.file, color=self.color, nl=False)
            self.file.flush()

    def make_step(self, n_steps):
        self.pos += n_steps
        if self.length_known and self.pos >= self.length:
            self.finished = True

        if (time.time() - self.last_eta) < 1.0:
            return

        self.last_eta = time.time()

        # self.avg is a rolling list of length <= 7 of steps where steps are
        # defined as time elapsed divided by the total progress through
        # self.length.
        if self.pos:
            step = (time.time() - self.start) / self.pos
        else:
            step = time.time() - self.start

        self.avg = self.avg[-6:] + [step]

        self.eta_known = self.length_known

    def update(self, n_steps):
        self.make_step(n_steps)
        self.render_progress()

    def finish(self):
        self.eta_known = 0
        self.current_item = None
        self.finished = True

    def generator(self):
<<<<<<< HEAD
        """
        Returns a generator which yields the items added to the bar during
        construction, and updates the progress bar *after* the yielded block
        returns.
        """
        if not self.entered:
            raise RuntimeError('You need to use progress bars in a with block.')
=======
        """Return a generator which yields the items added to the bar
        during construction, and updates the progress bar *after* the
        yielded block returns.
        """
        # WARNING: the iterator interface for `ProgressBar` relies on
        # this and only works because this is a simple generator which
        # doesn't create or manage additional state. If this function
        # changes, the impact should be evaluated both against
        # `iter(bar)` and `next(bar)`. `next()` in particular may call
        # `self.generator()` repeatedly, and this must remain safe in
        # order for that interface to work.
        if not self.entered:
            raise RuntimeError("You need to use progress bars in a with block.")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

        if self.is_hidden:
            for rv in self.iter:
                yield rv
        else:
            for rv in self.iter:
                self.current_item = rv
                yield rv
                self.update(1)
            self.finish()
            self.render_progress()


def pager(generator, color=None):
    """Decide what method to use for paging through text."""
    stdout = _default_text_stdout()
    if not isatty(sys.stdin) or not isatty(stdout):
        return _nullpager(stdout, generator, color)
<<<<<<< HEAD
    pager_cmd = (os.environ.get('PAGER', None) or '').strip()
=======
    pager_cmd = (os.environ.get("PAGER", None) or "").strip()
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    if pager_cmd:
        if WIN:
            return _tempfilepager(generator, pager_cmd, color)
        return _pipepager(generator, pager_cmd, color)
<<<<<<< HEAD
    if os.environ.get('TERM') in ('dumb', 'emacs'):
        return _nullpager(stdout, generator, color)
    if WIN or sys.platform.startswith('os2'):
        return _tempfilepager(generator, 'more <', color)
    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:
        return _pipepager(generator, 'less', color)

    import tempfile
    fd, filename = tempfile.mkstemp()
    os.close(fd)
    try:
        if hasattr(os, 'system') and os.system('more "%s"' % filename) == 0:
            return _pipepager(generator, 'more', color)
=======
    if os.environ.get("TERM") in ("dumb", "emacs"):
        return _nullpager(stdout, generator, color)
    if WIN or sys.platform.startswith("os2"):
        return _tempfilepager(generator, "more <", color)
    if hasattr(os, "system") and os.system("(less) 2>/dev/null") == 0:
        return _pipepager(generator, "less", color)

    import tempfile

    fd, filename = tempfile.mkstemp()
    os.close(fd)
    try:
        if (
            hasattr(os, "system")
            and os.system("more {}".format(shlex_quote(filename))) == 0
        ):
            return _pipepager(generator, "more", color)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return _nullpager(stdout, generator, color)
    finally:
        os.unlink(filename)


def _pipepager(generator, cmd, color):
    """Page through text by feeding it to another program.  Invoking a
    pager through this might support colors.
    """
    import subprocess
<<<<<<< HEAD
=======

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    env = dict(os.environ)

    # If we're piping to less we might support colors under the
    # condition that
<<<<<<< HEAD
    cmd_detail = cmd.rsplit('/', 1)[-1].split()
    if color is None and cmd_detail[0] == 'less':
        less_flags = os.environ.get('LESS', '') + ' '.join(cmd_detail[1:])
        if not less_flags:
            env['LESS'] = '-R'
            color = True
        elif 'r' in less_flags or 'R' in less_flags:
            color = True

    c = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
                         env=env)
=======
    cmd_detail = cmd.rsplit("/", 1)[-1].split()
    if color is None and cmd_detail[0] == "less":
        less_flags = "{}{}".format(os.environ.get("LESS", ""), " ".join(cmd_detail[1:]))
        if not less_flags:
            env["LESS"] = "-R"
            color = True
        elif "r" in less_flags or "R" in less_flags:
            color = True

    c = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, env=env)
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    encoding = get_best_encoding(c.stdin)
    try:
        for text in generator:
            if not color:
                text = strip_ansi(text)

<<<<<<< HEAD
            c.stdin.write(text.encode(encoding, 'replace'))
=======
            c.stdin.write(text.encode(encoding, "replace"))
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    except (IOError, KeyboardInterrupt):
        pass
    else:
        c.stdin.close()

    # Less doesn't respect ^C, but catches it for its own UI purposes (aborting
    # search or other commands inside less).
    #
    # That means when the user hits ^C, the parent process (click) terminates,
    # but less is still alive, paging the output and messing up the terminal.
    #
    # If the user wants to make the pager exit on ^C, they should set
    # `LESS='-K'`. It's not our decision to make.
    while True:
        try:
            c.wait()
        except KeyboardInterrupt:
            pass
        else:
            break


def _tempfilepager(generator, cmd, color):
    """Page through text by invoking a program on a temporary file."""
    import tempfile
<<<<<<< HEAD
=======

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    filename = tempfile.mktemp()
    # TODO: This never terminates if the passed generator never terminates.
    text = "".join(generator)
    if not color:
        text = strip_ansi(text)
    encoding = get_best_encoding(sys.stdout)
<<<<<<< HEAD
    with open_stream(filename, 'wb')[0] as f:
        f.write(text.encode(encoding))
    try:
        os.system(cmd + ' "' + filename + '"')
=======
    with open_stream(filename, "wb")[0] as f:
        f.write(text.encode(encoding))
    try:
        os.system("{} {}".format(shlex_quote(cmd), shlex_quote(filename)))
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
    finally:
        os.unlink(filename)


def _nullpager(stream, generator, color):
    """Simply print unformatted text.  This is the ultimate fallback."""
    for text in generator:
        if not color:
            text = strip_ansi(text)
        stream.write(text)


class Editor(object):
<<<<<<< HEAD

    def __init__(self, editor=None, env=None, require_save=True,
                 extension='.txt'):
=======
    def __init__(self, editor=None, env=None, require_save=True, extension=".txt"):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        self.editor = editor
        self.env = env
        self.require_save = require_save
        self.extension = extension

    def get_editor(self):
        if self.editor is not None:
            return self.editor
<<<<<<< HEAD
        for key in 'VISUAL', 'EDITOR':
=======
        for key in "VISUAL", "EDITOR":
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            rv = os.environ.get(key)
            if rv:
                return rv
        if WIN:
<<<<<<< HEAD
            return 'notepad'
        for editor in 'vim', 'nano':
            if os.system('which %s >/dev/null 2>&1' % editor) == 0:
                return editor
        return 'vi'

    def edit_file(self, filename):
        import subprocess
=======
            return "notepad"
        for editor in "sensible-editor", "vim", "nano":
            if os.system("which {} >/dev/null 2>&1".format(editor)) == 0:
                return editor
        return "vi"

    def edit_file(self, filename):
        import subprocess

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        editor = self.get_editor()
        if self.env:
            environ = os.environ.copy()
            environ.update(self.env)
        else:
            environ = None
        try:
<<<<<<< HEAD
            c = subprocess.Popen('%s "%s"' % (editor, filename),
                                 env=environ, shell=True)
            exit_code = c.wait()
            if exit_code != 0:
                raise ClickException('%s: Editing failed!' % editor)
        except OSError as e:
            raise ClickException('%s: Editing failed: %s' % (editor, e))
=======
            c = subprocess.Popen(
                "{} {}".format(shlex_quote(editor), shlex_quote(filename)),
                env=environ,
                shell=True,
            )
            exit_code = c.wait()
            if exit_code != 0:
                raise ClickException("{}: Editing failed!".format(editor))
        except OSError as e:
            raise ClickException("{}: Editing failed: {}".format(editor, e))
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f

    def edit(self, text):
        import tempfile

<<<<<<< HEAD
        text = text or ''
        if text and not text.endswith('\n'):
            text += '\n'

        fd, name = tempfile.mkstemp(prefix='editor-', suffix=self.extension)
        try:
            if WIN:
                encoding = 'utf-8-sig'
                text = text.replace('\n', '\r\n')
            else:
                encoding = 'utf-8'
            text = text.encode(encoding)

            f = os.fdopen(fd, 'wb')
=======
        text = text or ""
        if text and not text.endswith("\n"):
            text += "\n"

        fd, name = tempfile.mkstemp(prefix="editor-", suffix=self.extension)
        try:
            if WIN:
                encoding = "utf-8-sig"
                text = text.replace("\n", "\r\n")
            else:
                encoding = "utf-8"
            text = text.encode(encoding)

            f = os.fdopen(fd, "wb")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            f.write(text)
            f.close()
            timestamp = os.path.getmtime(name)

            self.edit_file(name)

<<<<<<< HEAD
            if self.require_save \
               and os.path.getmtime(name) == timestamp:
                return None

            f = open(name, 'rb')
=======
            if self.require_save and os.path.getmtime(name) == timestamp:
                return None

            f = open(name, "rb")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            try:
                rv = f.read()
            finally:
                f.close()
<<<<<<< HEAD
            return rv.decode('utf-8-sig').replace('\r\n', '\n')
=======
            return rv.decode("utf-8-sig").replace("\r\n", "\n")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        finally:
            os.unlink(name)


def open_url(url, wait=False, locate=False):
    import subprocess

    def _unquote_file(url):
        try:
            import urllib
        except ImportError:
            import urllib
<<<<<<< HEAD
        if url.startswith('file://'):
            url = urllib.unquote(url[7:])
        return url

    if sys.platform == 'darwin':
        args = ['open']
        if wait:
            args.append('-W')
        if locate:
            args.append('-R')
        args.append(_unquote_file(url))
        null = open('/dev/null', 'w')
=======
        if url.startswith("file://"):
            url = urllib.unquote(url[7:])
        return url

    if sys.platform == "darwin":
        args = ["open"]
        if wait:
            args.append("-W")
        if locate:
            args.append("-R")
        args.append(_unquote_file(url))
        null = open("/dev/null", "w")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        try:
            return subprocess.Popen(args, stderr=null).wait()
        finally:
            null.close()
    elif WIN:
        if locate:
            url = _unquote_file(url)
<<<<<<< HEAD
            args = 'explorer /select,"%s"' % _unquote_file(
                url.replace('"', ''))
        else:
            args = 'start %s "" "%s"' % (
                wait and '/WAIT' or '', url.replace('"', ''))
=======
            args = "explorer /select,{}".format(shlex_quote(url))
        else:
            args = 'start {} "" {}'.format("/WAIT" if wait else "", shlex_quote(url))
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return os.system(args)
    elif CYGWIN:
        if locate:
            url = _unquote_file(url)
<<<<<<< HEAD
            args = 'cygstart "%s"' % (os.path.dirname(url).replace('"', ''))
        else:
            args = 'cygstart %s "%s"' % (
                wait and '-w' or '', url.replace('"', ''))
=======
            args = "cygstart {}".format(shlex_quote(os.path.dirname(url)))
        else:
            args = "cygstart {} {}".format("-w" if wait else "", shlex_quote(url))
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        return os.system(args)

    try:
        if locate:
<<<<<<< HEAD
            url = os.path.dirname(_unquote_file(url)) or '.'
        else:
            url = _unquote_file(url)
        c = subprocess.Popen(['xdg-open', url])
=======
            url = os.path.dirname(_unquote_file(url)) or "."
        else:
            url = _unquote_file(url)
        c = subprocess.Popen(["xdg-open", url])
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        if wait:
            return c.wait()
        return 0
    except OSError:
<<<<<<< HEAD
        if url.startswith(('http://', 'https://')) and not locate and not wait:
            import webbrowser
=======
        if url.startswith(("http://", "https://")) and not locate and not wait:
            import webbrowser

>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            webbrowser.open(url)
            return 0
        return 1


def _translate_ch_to_exc(ch):
<<<<<<< HEAD
    if ch == u'\x03':
        raise KeyboardInterrupt()
    if ch == u'\x04' and not WIN:  # Unix-like, Ctrl+D
        raise EOFError()
    if ch == u'\x1a' and WIN:      # Windows, Ctrl+Z
=======
    if ch == u"\x03":
        raise KeyboardInterrupt()
    if ch == u"\x04" and not WIN:  # Unix-like, Ctrl+D
        raise EOFError()
    if ch == u"\x1a" and WIN:  # Windows, Ctrl+Z
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
        raise EOFError()


if WIN:
    import msvcrt

    @contextlib.contextmanager
    def raw_terminal():
        yield

    def getchar(echo):
        # The function `getch` will return a bytes object corresponding to
        # the pressed character. Since Windows 10 build 1803, it will also
        # return \x00 when called a second time after pressing a regular key.
        #
        # `getwch` does not share this probably-bugged behavior. Moreover, it
        # returns a Unicode object by default, which is what we want.
        #
        # Either of these functions will return \x00 or \xe0 to indicate
        # a special key, and you need to call the same function again to get
        # the "rest" of the code. The fun part is that \u00e0 is
        # "latin small letter a with grave", so if you type that on a French
        # keyboard, you _also_ get a \xe0.
        # E.g., consider the Up arrow. This returns \xe0 and then \x48. The
        # resulting Unicode string reads as "a with grave" + "capital H".
        # This is indistinguishable from when the user actually types
        # "a with grave" and then "capital H".
        #
        # When \xe0 is returned, we assume it's part of a special-key sequence
        # and call `getwch` again, but that means that when the user types
        # the \u00e0 character, `getchar` doesn't return until a second
        # character is typed.
        # The alternative is returning immediately, but that would mess up
        # cross-platform handling of arrow keys and others that start with
        # \xe0. Another option is using `getch`, but then we can't reliably
        # read non-ASCII characters, because return values of `getch` are
        # limited to the current 8-bit codepage.
        #
        # Anyway, Click doesn't claim to do this Right(tm), and using `getwch`
        # is doing the right thing in more situations than with `getch`.
        if echo:
            func = msvcrt.getwche
        else:
            func = msvcrt.getwch

        rv = func()
<<<<<<< HEAD
        if rv in (u'\x00', u'\xe0'):
=======
        if rv in (u"\x00", u"\xe0"):
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            # \x00 and \xe0 are control characters that indicate special key,
            # see above.
            rv += func()
        _translate_ch_to_exc(rv)
        return rv
<<<<<<< HEAD
=======


>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
else:
    import tty
    import termios

    @contextlib.contextmanager
    def raw_terminal():
        if not isatty(sys.stdin):
<<<<<<< HEAD
            f = open('/dev/tty')
=======
            f = open("/dev/tty")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            fd = f.fileno()
        else:
            fd = sys.stdin.fileno()
            f = None
        try:
            old_settings = termios.tcgetattr(fd)
            try:
                tty.setraw(fd)
                yield fd
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                sys.stdout.flush()
                if f is not None:
                    f.close()
        except termios.error:
            pass

    def getchar(echo):
        with raw_terminal() as fd:
            ch = os.read(fd, 32)
<<<<<<< HEAD
            ch = ch.decode(get_best_encoding(sys.stdin), 'replace')
=======
            ch = ch.decode(get_best_encoding(sys.stdin), "replace")
>>>>>>> 08cf566694c2c63d615f5d40137fa82e6bddcc6f
            if echo and isatty(sys.stdout):
                sys.stdout.write(ch)
            _translate_ch_to_exc(ch)
            return ch
